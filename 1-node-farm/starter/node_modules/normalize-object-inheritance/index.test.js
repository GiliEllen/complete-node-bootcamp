import { expect } from 'chai';

import normalizeObject from './index.js'

const timeIt = (fn) => {
    const start = performance.now();
    fn();
    const end = performance.now();

    return end - start;
}

const genObj = () => {
    let obj = {
        'fizz': 'buzz',
        2: '3',
        3: 2,
        arr: [],
    }

    obj['null'] = Object.create(null);
    obj['null']['hi'] = 'ho';
    obj['null'][2] = '3';
    obj['null'][3] = 2;
    obj['null']['null'] = Object.create(null);
    obj['null']['null']['5'] = '10';

    for (let index = 0; index < 5; index++) {
        const newObject = Object.create(null);
        newObject[index] = index;
        obj['arr'].push(newObject);
    }

    return obj;
}

describe('normalizeObject', () => {
    it('Check if a normal object is not altered', () => {
        const obj = genObj()

        const altered = genObj();
        normalizeObject(altered);

        expect(altered).to.deep.eq(obj);
    });

    it('Check if a non-normal object is properly normalized', () => {
        const obj = genObj();
        normalizeObject(obj);
        expect(obj['null']).to.be.an.instanceOf(Object);
        expect(obj['null']['null']).to.be.an.instanceOf(Object);
        for (const object of obj['arr']) {
            expect(object).to.be.an.instanceOf(Object);
        }
    });

    it('should convert the root object as well', () => {
        let obj = Object.create(null);
        obj[1] = 2;
        obj[3] = 4;

        obj = normalizeObject(obj);

        expect(obj).to.be.an.instanceOf(Object);
    });

    it('Should be faster than using JSON.parse(JSON.stringify(obj))', () => {
        let obj = genObj();
        const jsonTime = timeIt(() => {
            obj = JSON.parse(JSON.stringify(obj));
        });

        obj = genObj();
        const libTime = timeIt(() => {
            obj = normalizeObject(obj);
        });

        console.log('json time: ', jsonTime);
        console.log('lib  time: ', libTime);
        console.log('Percentage faster', (jsonTime - libTime) / jsonTime * 100 )

        expect(libTime).to.be.below(jsonTime);
    });
});
